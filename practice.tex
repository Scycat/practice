\documentclass[a4paper,12pt]{article}
\usepackage{color}
\usepackage{amsmath}
\usepackage[cp1251]{inputenc}%включаем свою кодировку: koi8-r или utf8 в UNIX, cp1251 в Windows
\usepackage[english,russian]{babel}%используем русский и английский языки с переносами
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{listings}
\lstset{ %
language=C,                 % выбор языка для подсветки (здесь это С)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}
%\makeindex
\usepackage{geometry} % Меняем поля страницы
\geometry{left=3cm}% левое поле
\geometry{right=1.5cm}% правое поле
\geometry{top=2cm}% верхнее поле
\geometry{bottom=2cm}% нижнее поле
%\renewcommand{\baselinestretch}{1.5}
%\title{\textbf{Проверка жирным}{ обычный}\textit{ курсив}}
%\date{\today{текущая дата}}
\begin{document}
\thispagestyle{empty}
\begin{center}
\textbf{САНКТ-ПЕТЕРБУРГСКИЙ НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ \\
УНИВЕРСИТЕТ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ, \\
МЕХАНИКИ И ОПТИКИ \\}
\end{center}
\begin{flushright}
{Факультет\hrulefill компьютерных технологий и управления\hrulefill \\
Кафедра \hrulefill вычислительной техники \hrulefill\\
Направление подготовки(специальность) \hrulefill 230100\hrulefill}
\end{flushright}
\vspace{8em}

\begin{center}
\Large \textbf{О Т Ч Е Т \\ по практике}
\end{center}

\vspace{2.5em}
 

\vspace{6em}
 
\begin{flushleft}
\textbf{Тема задания:}  \hrulefill тема \hrulefill \\
\vspace{1.5em}
\textbf{Студенты}  \hrulefill Вакс Алексей, { }группа 3103\hrulefill\hrulefill\hrulefill\\
\vspace{1.5em}
\textbf{Руководитель практики} \hrulefill Соснин В.В. \hrulefill\\
\vspace{1.5em}
\textbf{Оценка руководителя}  \hrulefill\makebox[6cm] { }
\end{flushleft}
 \vspace{6em}
 \makebox[11cm]{}\textbf{Дата} \hrulefill
 
\vspace{\fill}

\begin{center}
\textbf{Санкт-Петербург \\
2013г.}  
\end{center}
\newpage
%\maketitle 

\begin{large} % кегль 14
\begin{spacing}{1.5} % межстрочный интервал - полуторный


\begin{flushleft}
\section{TeX(LaTeX)} 
\end{flushleft}

\TeX{} - система компьютерной вёрстки, разработанная Дональдом Кнутом в целях создания компьютерной типографии. В отличие от визуальных редакторов, \TeX{} сам форматирует документ на основе выбранного пользователем шаблона — как правило, хранящегося в файле формата .tex. Далее файлы .tex транслируются в файлы .dvi, которые уже могут быть напечатаны либо перегнаны в формат pdf.

\TeX/{} предназначен для набора научного текста, на большую часть состоящего из формул, и обеспечивает удобное форматирование и оформление текста, перекрестных ссыло и библиографии, а также позволяет создавать более качественные сложные документы, чем WYSIWYG-редакторы — такие как MS Word.

Документы набираются на собственном низкоуровневом языке разметки \TeX{}, содержащем команды отступа и смены шрифта, а также расширением \TeX{}'а — \LaTeX{}'ом, который содержит в себе набором готовых стилей и шаблонов, позволяющих, например, быстро вставлять оглавнение, не задумываясь о нумерации отдельных объектов, что в MS Word гораздо сложнее.

Главным преимуществом \TeX{} является возможность автоматизировать форматирование и структурирование документа, а также более гибкие возможности набора сложных формул, а также обеспечение кроссплатформенности и совместимости с PS и PDF.

Главным недостатком \TeX{} является сложность в освоении и адаптации после  WYSIWYG-редакторов, а также некоторые затруднения при работе с графикой, так как необходимо создавать для этого .eps-файл.

\subsection{MiKTeX} 
MiKTeX - открытый дистрибутив \TeX{} для платформы Windows, имеющий возможность автоматического обновления установленных компонентов и пакетов.

В состав MiKTeX включены:
\begin{spacing}{1.0}
\begin{itemize}% начало помеченного списка
\item классический \TeX -компилятор;
\item различные варианты TeX: pdfTeX, e-TeX, pdf-e-TeX, и т.д.;
\item конверторы TeX в PDF;
\item MetaPost — интерпретатор для графических иллюстраций;
\item полный набор общеиспользуемых макропакетов: LaTeX, ConTeXt и др.;
\item средство просмотра Yap;
\item инструменты и утилиты;
\end{itemize}% конец помеченного списка
\end{spacing}
\section{Git} 
Git - система управления версиями файлов, предназначенная для хранения, разделения и слияния версий и сохранения всей истории разработки в репозитории.

Для сохранения изменений используется команда commit.

Система контроля версий необходима для того, чтобы каждый из группы разработчиков
видел свои собственные изменения, а также изменения, сделанные его коллегами,
чтобы организовать быструю замену нужных файлов для замены всех модулей
на модули последних версий, а также для возможностей возврата к предыдущим.

В Git между главным репозиторием и пользователем существует промежуточный репозиторий — локальный, который обеспечивает работу системы без интернета.
\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{1}
\end{figure}

\subsection{Описание работы Git:} 
 
Сотрудник работает в своем рабочем пространстве (workspace), система параллельно с его изменениями вносит изменения в главный индекс, следя за теми файлами, которые добавил сотрудник. После этого сотрудник может сохранить текущее состояние. Далее файлы добавляются в локальный репозиторий. 

При наличии интернета сотрудник может перенести файлы в удаленный репозиторий (например, github). После этого из удаленного репозитория можно загрузить все файлы с текущими изменениями, а также просмотреть изменения текущей версии. Кроме того, другие пользователи также могут одновременно загружать свои изменения.
\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{3}
\end{figure}

\subsection{Основные git-команды:} 

\textbf{git init} - создание нового каталога с файлами нового репозитория.\\
\textbf{git commit} - сохранение изменений.\\
\textbf{git status} - вывод информации обо всех изменениях, внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей ветки.\\
\textbf{git add} - ввод в индекс (временное хранилище) изменений, которые затем войдут в commit.\\


\textit{Основные ключи, используемые для упрощения работы с git:}\\
\textbf{\textit{git commit -a}} - выполняет commit, индексируя изменения в файлах проекта без индексации новых файлов, но с учитыванием удаления.\\
\textbf{\textit{git commit -m «commit comment»}} - комментируем commit из командной строки вместо текстового редактора.\\
\textbf{\textit{git commit "filename"}} - вносит в индекс и создаёт commit на основе изменений только одного файла. \\
\textbf{git reset} - возврат к определенному commit'у, откат изменений, «жесткий» или «мягкий». Мягкий оставляет индекс и дерево файлов и директорий нетронутым, а жёсткий возвращает указанное состояние, удаляя все последующие изменения, вызванные commit'ами.\\
\textbf{git diff} - просмотр изменений, не внесенных в индекс.\\
\textbf{git push} - внесение изменения в удаленный репозиторий.\\
\textbf{git pull} - возвращает изменения из удаленного репозитория.


Использованные материалы: http://git-scm.com/, http://robotics.usc.edu/.
\section{Взвешенная справедливая очередь}

Взвешенная справедливая очередь (англ. Weighted fair queuing, WFQ) — механизм планирования пакетных потоков данных с различными приоритетами. Его целью является регулирование использования одного канала передачи данных несколькими конкурирующими очередями пакетов данных.

Взвешенная справедливая очередь -- это комбинированный механизм, сочетающий приоритетное обслуживание с взвешенным и используя принципы и того и другого. От приоритетного обслуживания взята возможность устанавливать препочтение одним очередям пакетов данных, а от взвешенного обслуживания взята возможность предоставлять всем очередям пакетов заявок определенный минимум пропускной способности, чтобы гарантировать некоторые требования к величине задержек.

Типичный вариант реализации WFQ, когда всем классам трафика достаются равные доли пропускной способности выходного интерфейса из оставшейся от трафика приоритетного класса доли:
\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{4}
\end{figure}
\subsection{Реализация WFQ на языке программирования}
Напишем программу, эмулирующую работу системы массового обслуживания по механизму WFQ с экспоненциальным распределением размеров пакетов (т.е. длительности обслуживания) и экспоненциальным потоком пакетов на языке С-Sharp в консольном приложении. 

\begin{lstlisting}[label=Source Code,caption=Source Code]
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace ConsoleApplication2
{
    class Program
    {
        public static double Gen(double mat) //генератор случайной величины, распределенной по экспоненциальному закону
        {
            double x = 0;
            var rnd = new Random();
            while (x == 0) x = -mat * (Math.Log(rnd.NextDouble()));
            return x;
        }
        public static bool ifnotnull(double[] arr)
        {
            bool ans = false;
            foreach (double x in arr)
                if (x != 0) ans = true; //значит, очередь не пуста
            return ans;
        }
        public static bool ifnotfull(double[] arr)
        {
            bool ans = false;
            foreach (double x in arr)
                if (x == 0)
                {
                    ans = true; //значит, в очереди есть свободное место
                    break;
                }
            return ans;
        }
        public static int numlast(double[] arr)
        {
            int ans = arr.Length;
            for (int i = 0; i < arr.Length; i++)
                if (arr[i] == 0)
                {
                    ans = i; //возврат номера последнего свободного места в очереди
                    break;
                }
            return ans;
        }
        static void Main(string[] args)
        {
            double timer = 0.08; //минимальная единица времени
            double timewait1sum = 0;
            int timewait1kol = 0;
            double timewait2sum = 0;
            int timewait2kol = 0;
            double finaltimewait1 = 0;
            double finaltimewait2 = 0;
            //переменные для определения среднего времени ожидания для разных накопителей
            double buf1m = 0, buf2m = 0; //расчет средней длины очереди
            double buf1ms = 0, buf2ms = 0;
            int kol = 0;
            int buf1size = 280, buf2size = 180; //размеры очередей
            int buf1 = 0, buf2 = 0;
            double[] arr1 = new double[buf1size]; //массивы с размерами пакетов (длительностью обслуживания заявок)
            double[] arr2 = new double[buf2size];
            double servtime1 = 0.2, servtime2 = 0.71; //среднее время обслуживания
            double intensity1 = 4.1, intensity2 = 2.2; //средняя интенсивность
            double kpd = 0;
            double load = 0;
            //гибкое переключение на другую очередь после обработки определенного кол-ва заявок, зависит от величины [Количество_недавно_обслуженных_заявок*Их_вес(вес равен длительности обслуживания)]
            double SWITCHINGFINAL1 = 40; // переключение после обработки стольких заявок 1й очереди
            double SWITCHINGFINAL2 = 60; // переключение после обработки стольких заявок 2й очереди
            double SWITCHINGPROGRESS = 0;
            //расширим эту переменную для переключения по величине, зависящей от конкретной очереди
            double SWITCHING = 1;
            //обнуление массивов
            for (int i = 0; i < buf1size; i++)
            {
                arr1[i] = 0;
            }
            for (int i = 0; i < buf2size; i++)
            {
                arr2[i] = 0;
            }
            
            //Главный цикл работы системы:
            for (double i = timer; i < 100000; i += timer)
            {
                //добавляем новые заявки в очередь
                kol = Convert.ToInt32(Gen(timer * intensity1));
                for (int j = 0; j < kol; j++)
                {
                    if (ifnotfull(arr1))
                    {
                        arr1[numlast(arr1)] = Gen(servtime1);
                        timewait1kol++;
                    }
                }
                kol = Convert.ToInt32(Gen(timer * intensity2));
                for (int j = 0; j < kol; j++)
                {
                    if (ifnotfull(arr2))
                    {
                        arr2[numlast(arr2)] = Gen(servtime2);
                        timewait2kol++;
                    }
                }
                //закончили добавлять новые заявки, теперь обслуживаем заявки, проверка переключения

                if ((SWITCHINGPROGRESS >= SWITCHINGFINAL1) && (SWITCHING == 1))
                {
                    SWITCHING = 2;

                    SWITCHINGPROGRESS = 0; //сбросили прогресс, переключились на очередь 2
                }

                if ((SWITCHINGPROGRESS >= SWITCHINGFINAL2) && (SWITCHING == 2))
                {
                    SWITCHING = 1;
                    SWITCHINGPROGRESS = 0; //сбросили прогресс, переключились на очередь 1
                }

                //обслуживание заявок
                if (SWITCHING == 1)
                {
                    if ((arr1[0] > 0))
                    {
                        arr1[0] -= servtime1;
                        SWITCHINGPROGRESS += servtime1;
                        timewait1sum += servtime1;//прирост времени ожидания
                        if ((arr2[0] > 0))
                        {
                            timewait2sum += servtime1; //прирост времени ожидания
                        }
                    }
                    else SWITCHING = 2; //если заявок в первой очереди нет, идем во вторую
                }

                if (SWITCHING == 2)
                {
                    if ((arr2[0] > 0))
                    {
                        arr2[0] -= servtime2;
                        SWITCHINGPROGRESS += servtime2;
                        timewait2sum += servtime2;//прирост времени ожидания
                        if ((arr1[0] > 0))
                        {
                            timewait1sum += servtime2;//прирост времени ожидания
                        }
                    }
                    else SWITCHING = 1; //если заявок во второй очереди нет, идем в первую
                }

                //закончили обслуживать заявки, теперь сдвигаем массив, чтобы на 1м месте не было "пустого места", а была заявка
                if ((arr1[0] <= 0))
                {
                    for (int j = 0; j < buf1size - 1; j++)
                    {
                        arr1[j] = arr1[j + 1];
                    }
                    arr1[buf1size - 1] = 0;
                }

                if ((arr2[0] <= 0))
                {
                    for (int j = 0; j < buf2size - 1; j++)
                    {
                        arr2[j] = arr2[j + 1];
                    }
                    arr2[buf2size - 1] = 0;
                }

                //подготавливаем информацию для вывода
                buf1 = numlast(arr1);
                buf2 = numlast(arr2);
                buf1ms += buf1;
                buf2ms += buf2;
                buf1m = buf1ms / (i / timer);
                buf2m = buf2ms / (i / timer);
                if ((timewait1kol != 0) && (timewait2kol != 0))
                {
                    finaltimewait1 = timewait1sum / timewait1kol;
                    finaltimewait2 = timewait2sum / timewait2kol;
                }
                Console.Clear();
                Console.WriteLine("В настоящее время обрабатываю заявки из очереди: " + SWITCHING + "\t");
                Console.WriteLine("Первая очередь: " + buf1 + "/" + buf1size + ". Вторая очередь: " + buf2 + "/" + buf2size + "\t");
                Console.WriteLine("Средняя первая оч.: " + buf1m + ". Средняя вторая оч.: " + buf2m + "\t");
                Console.WriteLine("Среднее время ожидания в 1й оч.: " + finaltimewait1 + ". Во 2й оч.: " + finaltimewait2 + "\t");
                Console.WriteLine("Средн. время обсл. в 1й очереди: " + servtime1 + ". Во 2й очереди: " + servtime2 + "\t");
                Console.WriteLine("Средн. интенсивн. заявок 1й оч.: " + intensity1 + ". Во 2й очереди: " + intensity2 + "\t");
                Console.WriteLine("Суммарный размер обработ. заявок для переключения в 1ю/2ю очередь: " + SWITCHINGFINAL2 + "/" + SWITCHINGFINAL1 + "\t");
                Thread.Sleep(10); //для нормальной отрисовки данных
            }
            Console.ReadLine();
        }
    }
}

\end{lstlisting}


\section{Выводы}
Таким образом, мы написали программу для эмуляции системы массового обслуживания с приоритетом WFQ (Взвешенная справедливая очередь, Weighted fair queuing) с экспоненциальным распределением длительности обслуживания заявок и экспоненциальным потоком заявок для двух классов заявок в двух накопителях. С помощью этой программы можно исследовать зависимости времени ожидания, а также средних и текущих длин очередей для обоих классов заявок от времени и от входных параметров, которые можно удобно менять на другие желаемые.

Технология WFQ позволяет сочетать преимущества взвешенного и приоритетного обслуживания одновременно, позволяя как давать более важным классам заявок повышенный приоритет, так и поддерживать пропускную способность в низших классах заявок на определенном уровне, таким образом, оптимизируя процесс обслуживания заявок (или обработки пакетов) в справедливом (выгодном) порядке.

Приоритет WFQ -- один из инструментов обеспечения заданного уровня качества обслуживания в сетях, в связи с чем часто используется в маршрутизаторах и коммутаторах.

\centering
Реализация СМО с приоритетом WFQ в написанной программе
\includegraphics[width=1\textwidth]{15}

\begin{figure}[h]
\centering
Результаты работы программы: 

\includegraphics[width=1\textwidth]{12a}
Обслуживание заявок из первого накопителя.
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{12b}
Обслуживание заявок из второго накопителя.
\end{figure}

\end{spacing}
\end{large}


%\LaTeX{} 


\end{document}
